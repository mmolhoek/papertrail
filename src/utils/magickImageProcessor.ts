/**
 * ImageMagick-based Image Processor
 *
 * Alternative to Sharp for image processing using wasm-imagemagick.
 * This module provides functions for loading images, resizing, and
 * converting to 1-bit bitmap format for e-paper displays.
 *
 * Used when USE_IMAGEMAGICK=true environment variable is set.
 */

import { getLogger } from "@utils/logger";
import * as fs from "fs";

const logger = getLogger("MagickImageProcessor");

// Lazy-load wasm-imagemagick to avoid Worker issues in Node.js tests
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let wasmImagemagick: any = null;

async function getWasmImagemagick() {
  if (!wasmImagemagick) {
    wasmImagemagick = await import("wasm-imagemagick");
  }
  return wasmImagemagick;
}

/**
 * Load an image file and convert it to 1-bit packed bitmap format
 * suitable for e-paper display
 */
export async function loadImageToBuffer(
  imagePath: string,
  targetWidth: number,
  targetHeight: number,
): Promise<Buffer> {
  const startTime = Date.now();
  logger.info(
    `Loading image: ${imagePath}, target size: ${targetWidth}x${targetHeight}`,
  );

  const wasm = await getWasmImagemagick();

  // Read the image file
  const imageBuffer = fs.readFileSync(imagePath);
  const imageContent = new Uint8Array(imageBuffer);

  // Determine file extension for input format
  const ext = imagePath.split(".").pop()?.toLowerCase() || "png";

  const inputFiles = [
    {
      name: `input.${ext}`,
      content: imageContent,
    },
  ];

  // Execute ImageMagick command to resize and convert to grayscale raw pixels
  const result = await wasm.execute({
    inputFiles,
    commands: [
      "convert",
      `input.${ext}`,
      "-resize",
      `${targetWidth}x${targetHeight}!`,
      "-background",
      "white",
      "-gravity",
      "center",
      "-extent",
      `${targetWidth}x${targetHeight}`,
      "-colorspace",
      "Gray",
      "-threshold",
      "50%",
      "-depth",
      "8",
      "GRAY:output.raw",
    ],
  });

  if (result.exitCode !== 0) {
    logger.error(`ImageMagick convert failed: ${result.stderr.join("\n")}`);
    throw new Error(`ImageMagick convert failed: ${result.stderr.join("\n")}`);
  }

  const outputFile = result.outputFiles.find(
    (f: { name: string }) => f.name === "output.raw",
  );
  if (!outputFile) {
    throw new Error("No output file generated by ImageMagick");
  }

  // Get raw pixel data
  let rawBuffer: Uint8Array;
  if (outputFile.buffer) {
    rawBuffer = new Uint8Array(outputFile.buffer);
  } else if (outputFile.blob) {
    const arrayBuffer = await outputFile.blob.arrayBuffer();
    rawBuffer = new Uint8Array(arrayBuffer);
  } else {
    throw new Error("Output file has no data");
  }

  // Pack into 1-bit format (8 pixels per byte, MSB first)
  const bytesPerRow = Math.ceil(targetWidth / 8);
  const totalBytes = bytesPerRow * targetHeight;
  const packed = Buffer.alloc(totalBytes, 0xff); // Start with all white

  for (let y = 0; y < targetHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      const pixelIndex = y * targetWidth + x;
      const byteIndex = y * bytesPerRow + Math.floor(x / 8);
      const bitIndex = 7 - (x % 8);

      // If pixel is black (value 0 in grayscale)
      if (pixelIndex < rawBuffer.length && rawBuffer[pixelIndex] === 0) {
        packed[byteIndex] &= ~(1 << bitIndex);
      }
    }
  }

  logger.info(`Image loaded and processed in ${Date.now() - startTime}ms`);
  return packed;
}

/**
 * Load an image from buffer (e.g., BMP data) and convert to 1-bit packed format
 */
export async function processImageBuffer(
  imageData: Buffer | Uint8Array,
  sourceWidth: number,
  sourceHeight: number,
  targetWidth: number,
  targetHeight: number,
  channels: number = 4,
): Promise<Buffer> {
  const startTime = Date.now();
  logger.debug(
    `Processing image buffer: ${sourceWidth}x${sourceHeight} -> ${targetWidth}x${targetHeight}`,
  );

  const wasm = await getWasmImagemagick();

  // Determine the pixel format string for ImageMagick based on channels
  let format: string;
  switch (channels) {
    case 1:
      format = "GRAY";
      break;
    case 3:
      format = "RGB";
      break;
    case 4:
      format = "RGBA";
      break;
    default:
      format = "RGBA";
  }

  // Create raw input file with explicit format
  const inputFiles = [
    {
      name: "input.raw",
      content:
        imageData instanceof Buffer ? new Uint8Array(imageData) : imageData,
    },
  ];

  // Execute ImageMagick command
  const result = await wasm.execute({
    inputFiles,
    commands: [
      "convert",
      "-size",
      `${sourceWidth}x${sourceHeight}`,
      "-depth",
      "8",
      `${format}:input.raw`,
      "-resize",
      `${targetWidth}x${targetHeight}`,
      "-colorspace",
      "Gray",
      "-threshold",
      "50%",
      "-depth",
      "8",
      "GRAY:output.raw",
    ],
  });

  if (result.exitCode !== 0) {
    logger.error(`ImageMagick convert failed: ${result.stderr.join("\n")}`);
    throw new Error(`ImageMagick convert failed: ${result.stderr.join("\n")}`);
  }

  const outputFile = result.outputFiles.find(
    (f: { name: string }) => f.name === "output.raw",
  );
  if (!outputFile) {
    throw new Error("No output file generated by ImageMagick");
  }

  // Get raw pixel data
  let rawBuffer: Uint8Array;
  if (outputFile.buffer) {
    rawBuffer = new Uint8Array(outputFile.buffer);
  } else if (outputFile.blob) {
    const arrayBuffer = await outputFile.blob.arrayBuffer();
    rawBuffer = new Uint8Array(arrayBuffer);
  } else {
    throw new Error("Output file has no data");
  }

  // Pack into 1-bit format
  const bytesPerRow = Math.ceil(targetWidth / 8);
  const totalBytes = bytesPerRow * targetHeight;
  const packed = Buffer.alloc(totalBytes, 0xff);

  for (let y = 0; y < targetHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      const pixelIndex = y * targetWidth + x;
      const byteIndex = y * bytesPerRow + Math.floor(x / 8);
      const bitIndex = 7 - (x % 8);

      if (pixelIndex < rawBuffer.length && rawBuffer[pixelIndex] === 0) {
        packed[byteIndex] &= ~(1 << bitIndex);
      }
    }
  }

  logger.debug(`Image buffer processed in ${Date.now() - startTime}ms`);
  return packed;
}

/**
 * Resize an image and convert to raw grayscale buffer
 * Returns raw 8-bit grayscale pixels (not packed)
 */
export async function resizeToGrayscale(
  imagePath: string,
  targetWidth: number,
  targetHeight: number,
): Promise<Buffer> {
  const startTime = Date.now();

  const wasm = await getWasmImagemagick();

  const imageBuffer = fs.readFileSync(imagePath);
  const imageContent = new Uint8Array(imageBuffer);
  const ext = imagePath.split(".").pop()?.toLowerCase() || "png";

  const inputFiles = [
    {
      name: `input.${ext}`,
      content: imageContent,
    },
  ];

  const result = await wasm.execute({
    inputFiles,
    commands: [
      "convert",
      `input.${ext}`,
      "-resize",
      `${targetWidth}x${targetHeight}`,
      "-background",
      "white",
      "-gravity",
      "center",
      "-extent",
      `${targetWidth}x${targetHeight}`,
      "-colorspace",
      "Gray",
      "-depth",
      "8",
      "GRAY:output.raw",
    ],
  });

  if (result.exitCode !== 0) {
    throw new Error(`ImageMagick convert failed: ${result.stderr.join("\n")}`);
  }

  const outputFile = result.outputFiles.find(
    (f: { name: string }) => f.name === "output.raw",
  );
  if (!outputFile) {
    throw new Error("No output file generated");
  }

  let rawBuffer: Uint8Array;
  if (outputFile.buffer) {
    rawBuffer = new Uint8Array(outputFile.buffer);
  } else if (outputFile.blob) {
    const arrayBuffer = await outputFile.blob.arrayBuffer();
    rawBuffer = new Uint8Array(arrayBuffer);
  } else {
    throw new Error("Output file has no data");
  }

  logger.debug(`Image resized to grayscale in ${Date.now() - startTime}ms`);
  return Buffer.from(rawBuffer);
}

/**
 * Convert BMP data to 1-bit packed bitmap
 */
export async function bmpToPackedBitmap(
  bmpData: Buffer,
  bmpWidth: number,
  bmpHeight: number,
  targetWidth: number,
  targetHeight: number,
): Promise<Buffer> {
  // BMP data from bmp-js is RGBA format
  return processImageBuffer(
    bmpData,
    bmpWidth,
    bmpHeight,
    targetWidth,
    targetHeight,
    4,
  );
}
